
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";


const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
};

async function graphql(token: string, query: string, variables: Record<string, unknown> = {}) {
  const res = await fetch("https://api.github.com/graphql", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ query, variables }),
  });
  const data = await res.json();
  if (data.errors) throw new Error(data.errors.map((e: any) => e.message).join(", "));
  return data.data;
}

interface ScrumTask {
  title: string;
  description: string;
  userStoryId: string;
  assignedTo: string;
  estimatedHours: number;
  requiredSkills: string[];
}

interface UserStory {
  id: string;
  title: string;
  description: string;
  priority: string;
  acceptanceCriteria?: string[];
}

interface Sprint {
  sprintNumber: number;
  goal: string;
  tasks: ScrumTask[];
}

interface ScrumResult {
  sprints: Sprint[];
  productBacklog: UserStory[];
}

interface GitHubUser {
  login: string;
}

interface GitHubRepo {
  number: number;
  node_id: string;
  message?: string;
}

interface GitHubIssue {
  number: number;
  node_id: string;
}

interface Label {
  name: string;
  color: string;
  description: string;
}

interface CreatedIssue {
  number: number;
  nodeId: string;
  sprint: number;
}

interface ProjectV2 {
  id: string;
  number: number;
  url: string;
}

interface RequestBody {
  accessToken: string;
  repoName: string;
  scrumResult: ScrumResult;
}

interface GraphQLError {
  message: string;
}

interface GraphQLResponse<T> {
  data?: T;
  errors?: GraphQLError[];
}

interface ViewerData {
  viewer: {
    id: string;
  };
}

interface CreateProjectV2Response {
  createProjectV2: {
    projectV2: ProjectV2;
  };
}

interface AddProjectV2ItemResponse {
  addProjectV2ItemById: {
    item: {
      id: string;
    };
  };
}

interface SuccessResponse {
  success: true;
  repoUrl: string;
  projectUrl: string;
  issuesCreated: number;
}

interface ErrorResponse {
  error: string;
}

serve(async (req: Request): Promise<Response> => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { accessToken, repoName, scrumResult } = await req.json() as RequestBody;

    if (!accessToken || !repoName || !scrumResult) {
      return new Response(JSON.stringify({ error: "Missing required fields" } as ErrorResponse), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // 1. Get authenticated user
    const userRes = await fetch("https://api.github.com/user", {
      headers: { Authorization: `Bearer ${accessToken}` },
    });
    const user = await userRes.json() as GitHubUser;
    const owner = user.login;

    // 2. Create repo
    const repoRes = await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: repoName,
        description: "Scrum board generated by ScrumAgent",
        auto_init: true,
        private: false,
      }),
    });
    const repo = await repoRes.json() as GitHubRepo;
    if (repoRes.status >= 400 && repo.message !== "Repository creation failed.") {
      // Repo might already exist, try to use it
      if (!repo.message?.includes("already exists")) {
        throw new Error(repo.message || "Failed to create repo");
      }
    }

    // 3. Create labels for priorities and sprints
    const labels: Label[] = [
      { name: "priority:must-have", color: "e11d48", description: "Must Have (MoSCoW)" },
      { name: "priority:should-have", color: "f59e0b", description: "Should Have (MoSCoW)" },
      { name: "priority:could-have", color: "3b82f6", description: "Could Have (MoSCoW)" },
      { name: "priority:wont-have", color: "6b7280", description: "Won't Have (MoSCoW)" },
      { name: "priority:high", color: "e11d48", description: "High priority" },
      { name: "priority:medium", color: "f59e0b", description: "Medium priority" },
      { name: "priority:low", color: "22c55e", description: "Low priority" },
    ];

    // Add sprint labels
    for (const sprint of scrumResult.sprints) {
      labels.push({
        name: `sprint:${sprint.sprintNumber}`,
        color: "8b5cf6",
        description: `Sprint ${sprint.sprintNumber} - ${sprint.goal}`,
      });
    }

    // Create labels (ignore errors for existing ones)
    for (const label of labels) {
      await fetch(`https://api.github.com/repos/${owner}/${repoName}/labels`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(label),
      });
    }

    // 4. Create issues for each task grouped by sprint
    const createdIssues: CreatedIssue[] = [];

    for (const sprint of scrumResult.sprints) {
      for (const task of sprint.tasks) {
        const userStory = scrumResult.productBacklog.find(
          (us: UserStory) => us.id === task.userStoryId
        );

        const priorityLabel = userStory
          ? `priority:${userStory.priority}`
          : "priority:medium";

        const body = [
          `## ${task.title}`,
          "",
          task.description,
          "",
          `**User Story:** ${task.userStoryId}`,
          `**Assigné à:** ${task.assignedTo}`,
          `**Estimation:** ${task.estimatedHours}h`,
          `**Compétences:** ${task.requiredSkills.join(", ")}`,
          "",
          userStory ? `### User Story: ${userStory.title}` : "",
          userStory ? userStory.description : "",
          userStory?.acceptanceCriteria?.length
            ? `\n**Critères d'acceptation:**\n${userStory.acceptanceCriteria.map((c: string) => `- [ ] ${c}`).join("\n")}`
            : "",
        ]
          .filter(Boolean)
          .join("\n");

        const issueRes = await fetch(
          `https://api.github.com/repos/${owner}/${repoName}/issues`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${accessToken}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              title: `[Sprint ${sprint.sprintNumber}] ${task.title}`,
              body,
              labels: [`sprint:${sprint.sprintNumber}`, priorityLabel],
            }),
          }
        );
        const issue = await issueRes.json() as GitHubIssue;
        createdIssues.push({
          number: issue.number,
          nodeId: issue.node_id,
          sprint: sprint.sprintNumber,
        });
      }
    }

    // 5. Create GitHub Project (V2) using GraphQL
    const viewerData = await graphql(accessToken, `query { viewer { id } }`) as ViewerData;
    const ownerId = viewerData.viewer.id;

    const projectData = await graphql(
      accessToken,
      `mutation($ownerId: ID!, $title: String!) {
        createProjectV2(input: { ownerId: $ownerId, title: $title }) {
          projectV2 { id number url }
        }
      }`,
      { ownerId, title: `ScrumAgent - ${repoName}` }
    ) as CreateProjectV2Response;

    const project = projectData.createProjectV2.projectV2 as ProjectV2;

    // 6. Add issues to project
    for (const issue of createdIssues) {
      try {
        await graphql(
          accessToken,
          `mutation($projectId: ID!, $contentId: ID!) {
            addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
              item { id }
            }
          }`,
          { projectId: project.id, contentId: issue.nodeId }
        ) as AddProjectV2ItemResponse;
      } catch {
        // Non-critical, continue
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        repoUrl: `https://github.com/${owner}/${repoName}`,
        projectUrl: project.url,
        issuesCreated: createdIssues.length,
      } as SuccessResponse),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    return new Response(JSON.stringify({ error: errorMessage } as ErrorResponse), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
